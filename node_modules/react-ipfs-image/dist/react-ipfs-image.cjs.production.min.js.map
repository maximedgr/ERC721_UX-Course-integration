{"version":3,"file":"react-ipfs-image.cjs.production.min.js","sources":["../src/utils.ts","../src/components/IpfsImage.tsx","../src/components/IpfsVideo.tsx","../src/components/IpfsAudio.tsx","../src/components/IpfsMedia.tsx"],"sourcesContent":["import { useEffect, useState } from 'react';\n\nexport const DEFAULT_IPFS_GATEWAY_URL = 'https://infura-ipfs.io/ipfs';\n\nexport const cleanUpHash = (hash: string) => {\n  // remove the leading 'ipfs://' if it exists\n  if (hash.startsWith('ipfs://')) {\n    return hash.substring(7);\n  }\n  return hash;\n};\n\nexport const getImgUriFromTokenUriHash = async (\n  tokenUriHash: string,\n  ipfsGatewayUrl = DEFAULT_IPFS_GATEWAY_URL\n) => {\n  const ipfsHash = cleanUpHash(tokenUriHash);\n  const ipfsUrl = `${ipfsGatewayUrl}/${ipfsHash}`;\n  const res = await (await fetch(ipfsUrl)).json();\n  return res.image as string;\n};\n\nexport const useImgUris = (tokenUriHashes: string[]) => {\n  const [imgURIs, setImgURIs] = useState<string[]>([]);\n\n  useEffect(() => {\n    const fetchImgUris = async () => {\n      const imgUris = await Promise.all(\n        tokenUriHashes.map(uriHash => getImgUriFromTokenUriHash(uriHash))\n      );\n      setImgURIs(imgUris);\n    };\n    fetchImgUris();\n  }, [tokenUriHashes]);\n\n  return imgURIs;\n};\n","import React from 'react';\nimport { HTMLAttributes, FC } from 'react';\nimport { cleanUpHash, DEFAULT_IPFS_GATEWAY_URL } from '../utils';\n\nexport interface IIpfsImageProps extends HTMLAttributes<HTMLImageElement> {\n  hash: string;\n  gatewayUrl?: string;\n}\n\nexport const IpfsImage: FC<IIpfsImageProps> = ({\n  hash,\n  gatewayUrl = DEFAULT_IPFS_GATEWAY_URL,\n  ...props\n}) => {\n  return <img src={`${gatewayUrl}/${cleanUpHash(hash)}`} {...props} />;\n};\n","import React from 'react';\nimport { HTMLAttributes, FC } from 'react';\nimport { cleanUpHash, DEFAULT_IPFS_GATEWAY_URL } from '../utils';\n\nexport interface IIpfsVideoProps extends HTMLAttributes<HTMLVideoElement> {\n  hash: string;\n  gatewayUrl?: string;\n  autoPlay?: boolean;\n  muted?: boolean;\n  loop?: boolean;\n  controls?: boolean;\n}\n\nexport const IpfsVideo: FC<IIpfsVideoProps> = ({\n  hash,\n  gatewayUrl = DEFAULT_IPFS_GATEWAY_URL,\n  autoPlay = true,\n  muted = true,\n  controls = true,\n  loop = true,\n  ...props\n}) => {\n  return (\n    <video loop autoPlay muted controls {...props}>\n      <source src={`${gatewayUrl}/${cleanUpHash(hash)}`} />\n    </video>\n  );\n};\n","import React from 'react';\nimport { HTMLAttributes, FC } from 'react';\nimport { cleanUpHash, DEFAULT_IPFS_GATEWAY_URL } from '../utils';\n\nexport interface IIpfsAudioProps extends HTMLAttributes<HTMLVideoElement> {\n  hash: string;\n  gatewayUrl?: string;\n  autoPlay?: boolean;\n  muted?: boolean;\n  loop?: boolean;\n  controls?: boolean;\n}\n\nexport const IpfsAudio: FC<IIpfsAudioProps> = ({\n  hash,\n  gatewayUrl = DEFAULT_IPFS_GATEWAY_URL,\n  autoPlay = true,\n  muted = false,\n  controls = true,\n  loop = false,\n  ...props\n}) => {\n  return (\n    <audio loop autoPlay muted controls {...props}>\n      <source src={`${gatewayUrl}/${cleanUpHash(hash)}`} />\n    </audio>\n  );\n};\n","import React, { useEffect, useState } from 'react';\nimport { FC } from 'react';\nimport { IIpfsVideoProps, IpfsVideo } from './IpfsVideo';\nimport { IIpfsImageProps, IpfsImage } from './IpfsImage';\n\nexport type IIpfsMediaProps = IIpfsVideoProps & IIpfsImageProps;\n\nexport const IpfsMedia: FC<IIpfsMediaProps> = ({\n  hash,\n  gatewayUrl,\n  autoPlay = true,\n  muted = true,\n  controls = true,\n  loop = true,\n  ...props\n}) => {\n  const [imgError, setImgError] = useState(false);\n  const [vidError, setVidError] = useState(false);\n\n  useEffect(() => {\n    setImgError(false);\n    setVidError(false);\n  }, [hash]);\n\n  return (\n    <>\n      {!imgError && (\n        <IpfsImage hash={hash} onError={() => setImgError(true)} {...props} />\n      )}\n      {!vidError && (\n        <IpfsVideo\n          hash={hash}\n          onError={() => setVidError(true)}\n          autoPlay={autoPlay}\n          muted={muted}\n          controls={controls}\n          loop={loop}\n          {...props}\n        />\n      )}\n    </>\n  );\n};\n"],"names":["cleanUpHash","hash","startsWith","substring","getImgUriFromTokenUriHash","tokenUriHash","ipfsGatewayUrl","ipfsHash","ipfsUrl","_context","fetch","json","image","IpfsImage","gatewayUrl","props","React","src","IpfsVideo","loop","autoPlay","muted","controls","useState","imgError","setImgError","vidError","setVidError","useEffect","onError","tokenUriHashes","imgURIs","setImgURIs","_context2","Promise","all","map","uriHash","fetchImgUris"],"mappings":"64NAEO,IAEMA,EAAc,SAACC,GAE1B,OAAIA,EAAKC,WAAW,WACXD,EAAKE,UAAU,GAEjBF,GAGIG,aAAyB,kBAAG,WACvCC,EACAC,GAFuC,QAAA,6BAAA,OAAA,sBAAA,OAAA,gBAEvCA,IAAAA,EAZsC,+BAchCC,EAAWP,EAAYK,GACvBG,EAAaF,MAAkBC,EALEE,SAMdC,MAAMF,GANQ,OAAA,OAAAC,gBAMEE,OANF,OAAA,gCAO5BC,OAP4B,OAAA,UAAA,0BAAH,qBAAA,2DCHzBC,EAAiC,gBAC5CZ,IAAAA,SACAa,WAAAA,aDTsC,gCCUnCC,SAEH,OAAOC,qCAAKC,IAAQH,MAAcd,EAAYC,IAAac,kECDhDG,EAAiC,gBAC5CjB,IAAAA,SACAa,WAAAA,aFbsC,gCEkBnCC,SAEH,OACEC,uCAAOG,QAAKC,YAASC,SAAMC,aAAaP,GACtCC,0BAAQC,IAAQH,MAAcd,EAAYC,mJCXF,gBAC5CA,IAAAA,SACAa,WAAAA,aHbsC,gCGkBnCC,SAEH,OACEC,uCAAOG,QAAKC,YAASC,SAAMC,aAAaP,GACtCC,0BAAQC,IAAQH,MAAcd,EAAYC,6CCjBF,gBAC5CA,IAAAA,KACAa,IACAM,SAAAA,oBACAC,MAAAA,oBACAC,SAAAA,oBACAH,KAAAA,gBACGJ,WAE6BQ,YAAS,GAAlCC,OAAUC,SACeF,YAAS,GAAlCG,OAAUC,OAOjB,OALAC,aAAU,WACRH,GAAY,GACZE,GAAY,KACX,CAAC1B,IAGFe,iCACIQ,GACAR,gBAACH,iBAAUZ,KAAMA,EAAM4B,QAAS,WAAA,OAAMJ,GAAY,KAAWV,KAE7DW,GACAV,gBAACE,iBACCjB,KAAMA,EACN4B,QAAS,WAAA,OAAMF,GAAY,IAC3BP,SAAUA,EACVC,MAAOA,EACPC,SAAUA,EACVH,KAAMA,GACFJ,iFJfY,SAACe,GACzB,MAA8BP,WAAmB,IAA1CQ,OAASC,OAYhB,OAVAJ,aAAU,uBACU,kBAAG,aAAA,6BAAA,OAAA,sBAAA,OAAA,OAAAK,SACGC,QAAQC,IAC5BL,EAAeM,KAAI,SAAAC,GAAO,OAAIjC,EAA0BiC,OAFvC,OAInBL,UAJmB,OAAA,UAAA,0BAAH,kBAAA,kCAMlBM,KACC,CAACR,IAEGC"}